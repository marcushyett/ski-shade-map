generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  // directUrl bypasses the connection pooler for migrations
  directUrl = env("DATABASE_URL_UNPOOLED")
}

model SkiArea {
  id          String   @id @default(cuid())
  osmId       String?  @unique
  name        String
  country     String?
  region      String?
  latitude    Float
  longitude   Float
  bounds      Json?    // {minLat, maxLat, minLng, maxLng}
  geometry    Json?    // GeoJSON geometry
  properties  Json?    // Additional OSM properties
  runs        Run[]
  lifts       Lift[]
  // Connected ski areas (for loading adjacent areas together)
  connectedTo   SkiAreaConnection[] @relation("SkiAreaFrom")
  connectedFrom SkiAreaConnection[] @relation("SkiAreaTo")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([country])
  @@index([name])
  @@index([latitude, longitude])
}

// Connections between ski areas (for loading adjacent areas together)
model SkiAreaConnection {
  id          String   @id @default(cuid())
  fromAreaId  String
  toAreaId    String
  fromArea    SkiArea  @relation("SkiAreaFrom", fields: [fromAreaId], references: [id], onDelete: Cascade)
  toArea      SkiArea  @relation("SkiAreaTo", fields: [toAreaId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())

  @@unique([fromAreaId, toAreaId])
  @@index([fromAreaId])
  @@index([toAreaId])
}

model Run {
  id          String   @id @default(cuid())
  osmId       String?  @unique
  name        String?
  difficulty  String?  // novice, easy, intermediate, advanced, expert
  status      String?  // open, closed, unknown
  locality    String?  // Village/town name from OpenSkiMap data
  geometry    Json     // GeoJSON LineString or Polygon
  properties  Json?
  skiAreaId   String
  skiArea     SkiArea  @relation(fields: [skiAreaId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([skiAreaId])
  @@index([locality])
  @@index([difficulty])
}

model Lift {
  id          String   @id @default(cuid())
  osmId       String?  @unique
  name        String?
  liftType    String?  // chairlift, gondola, drag, cable_car, etc.
  status      String?  // open, closed, unknown
  locality    String?  // Village/town name from OpenSkiMap data
  capacity    Int?
  geometry    Json     // GeoJSON LineString
  properties  Json?
  skiAreaId   String
  skiArea     SkiArea  @relation(fields: [skiAreaId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([skiAreaId])
  @@index([locality])
}

model DataSync {
  id          String   @id @default(cuid())
  dataType    String   // ski_areas, runs, lifts, sub_regions
  lastSync    DateTime
  recordCount Int
  status      String   // success, failed, in_progress
  error       String?
  createdAt   DateTime @default(now())
}

// Analytics table for tracking resort status over time
// Denormalized to have one row per asset (lift or run) per collection timestamp
model ResortStatusAnalytics {
  id          String   @id @default(cuid())
  resortId    String   // Resort ID from ski-resort-status
  resortName  String   // Resort name for easier querying
  assetType   String   // "lift" or "run"
  assetId     String   // Asset name (used as identifier since openskimapIds can be empty)
  statusInfo  Json     // Full status blob (LiftStatus or RunStatus)
  statusHash  String?  // MD5 hash of statusInfo for efficient deduplication (computed in Node.js)
  collectedAt DateTime @default(now()) // When this data was collected

  @@index([resortId])
  @@index([assetType])
  @@index([collectedAt])
  @@index([resortId, assetType, collectedAt])
  @@index([resortId, assetType, assetId]) // For efficient latest-record lookup during deduplication
}
